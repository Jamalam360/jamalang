{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jamalang","text":"<p>Jamalang is a transpiled, statically typed langauge with powerful type inference. While not strictly object-oriented due to it's lack of traditional inheritance, it still provides composability through via it's constraint system. Jamalang also contains a powerful FFI system, allowing for the use of existing libraries for any language that can compile to LLVM IR/bitcode.</p>"},{"location":"#standard-library-philosophy","title":"Standard Library Philosophy","text":"<p>A lot of Jamalang's functionality is encapsulated in its standard library, implemented in Rust. The standard library contains types such as <code>String</code> and <code>List</code>. It is composed of a <code>core</code> module, which is automatically imported into any program, and other modules that can optionally be imported.</p>"},{"location":"specification/introduction/","title":"Jamalang - A Toy Language","text":""},{"location":"specification/introduction/#built-in-types","title":"Built-in Types","text":""},{"location":"specification/introduction/#bool","title":"<code>Bool</code>","text":"<p>A one-bit integer - true or false.</p>"},{"location":"specification/introduction/#signedint","title":"<code>SignedInt</code>","text":"<p>The <code>SignedInt</code> type is a 32-bit signed integer (i.e. it can be negative).</p>"},{"location":"specification/introduction/#long","title":"<code>Long</code>","text":"<p>The <code>Long</code> type is a 64-bit signed integer.</p>"},{"location":"specification/introduction/#float","title":"<code>Float</code>","text":"<p>The <code>Float</code> type is a 32-bit floating point number.</p>"},{"location":"specification/introduction/#double","title":"<code>Double</code>","text":"<p>The <code>Double</code> type is a 64-bit floating point number.</p>"},{"location":"specification/introduction/#boolean","title":"<code>Boolean</code>","text":"<p>The <code>Boolean</code> type is a <code>true</code> or <code>false</code> value.</p>"},{"location":"specification/introduction/#char","title":"<code>Char</code>","text":"<p>The <code>Char</code> type is a single unicode character.</p>"},{"location":"specification/introduction/#void","title":"<code>Void</code>","text":"<p>The <code>Void</code> type is the type of a function that does not return a value, and of an unassigned value (similar to <code>null</code> or <code>undefined</code> in other languages).</p>"},{"location":"specification/introduction/#object","title":"<code>Object</code>","text":"<p>The <code>Object</code> type is the base type of all objects. It can be used for types that generically accept any object.</p>"},{"location":"specification/introduction/#arrays","title":"Arrays","text":"<p>Arrays are a collection of values of the same type. They are not dynamic - the <code>List</code> type of the standard library is.</p>"},{"location":"specification/introduction/#type-and-constraint-system","title":"Type and Constraint System","text":"<p>The constraint system is a way of defining the behavior and abilities of a type (which can eventually be used to define a new object). To best explain the constraint system, here is a <code>Person</code> type:</p> <pre><code>type Person satisfies StringConvertible, Equatable, Comparable {\n    private UnsignedInt id\n    UnsignedInt age\n    Float height\n    Person[] friends\n\n    override String to_string(Person self) {\n        return \"\n            Person {\n                id: {self.id},\n                age: {self.age},\n                height: {self.height},\n                friends: {self.friends}\n            }\n        \".trim()\n    }\n\n    override Bool equals(Person self, Person other) {\n        return self.id == other.id\n    }\n\n    override SignedInt compare(Person self, Person other) {\n        return self.id - other.id\n    }\n}\n</code></pre> <p>The <code>Person</code> type is defined using the <code>type</code> keyword, and is defined to satisfy the constraints <code>StringConvertible</code>, <code>Equatable</code>, and <code>Comparable</code>.</p> <p>As can be seen by the <code>override</code> keyword, <code>to_string</code>, <code>equals</code>, and <code>compare</code> are all methods that are defined in the <code>StringConvertible</code>, <code>Equatable</code>, and <code>Comparable</code> constraints, respectively. This means that the <code>Person</code> type must implement these methods.</p> <p>To extend on the example, since the <code>Person</code> type satisfies <code>Equatable</code>, we could use it in an <code>if</code> statement:</p> <pre><code>if person1 is person2 {\n    // ...\n}\n</code></pre> <p>The <code>if</code> statement would call the <code>equals</code> method on <code>person1</code> and <code>person2</code>.</p> <p>Another example is that, since the <code>Person</code> satisfies the <code>StringConvertible</code> constraint, we could use it in a <code>print</code> statement. For the sake of this example, we'll define our own <code>print</code> function:</p> <pre><code>Void print(StringConvertable value) {\n    //\n}\n\nprint(person1)\n</code></pre>"},{"location":"specification/introduction/#type-aliases","title":"Type Aliases","text":"<p>Type-aliases can be used to give types more descriptive names or shorten commonly used types:</p> <pre><code>type ID = alias UnsignedInt\ntype StringConsumer = alias (String): Void\n</code></pre>"},{"location":"specification/introduction/#imports-and-wasm","title":"Imports and WASM","text":"<p>Jamalang has the ability to import from other files, such as the standard library.</p> <p>[TODO]</p>"},{"location":"specification/introduction/#functions-as-parameters","title":"Functions as Parameters","text":"<p>In Jamalang, functions can be defined as the last argument to another function.</p> <p>For example,</p> <pre><code>fn use_hello(append: String, func: (String): Void) {\n    func(\"Hello \" + append)\n}\n\nuse_hello(\"World\") -&gt; (str) { \n    print(str)\n}\n\n# This is a more helpful example:\n\nfiles_matching(\"**/*.json\") -&gt; (file) {\n    file.delete()\n}\n</code></pre>"},{"location":"specification/introduction/#examples","title":"Examples","text":"<pre><code>use Random from \"https://raw.githubusercontent.com/Jamalam360/jamalang/main/std/random.jamalang\"\nuse IO from \"https://raw.githubusercontent.com/Jamalam360/jamalang/main/std/io.jamalang\"\n\nfn add_or_subtract(a: UnsignedInt, b: UnsignedInt): UnsignedInt {\n    if Random.boolean() {\n        return a - b\n    } else {\n        return a + b\n    }\n}\n\n# IO.prompt result is casted from `String` to `SignedInt`\ninp1: SignedInt = IO.prompt(\"Enter a number: \")\ninp2: SignedInt = IO.prompt(\"Enter a number: \")\n\nIO.writeLine(\"Result: {add_or_subtract(inp1, inp2)}\")\n</code></pre> <pre><code>use IO from \"https://raw.githubusercontent.com/Jamalam360/jamalang/main/std/io.jamalang\"\n\nglob = IO.prompt(\"Enter file glob: \")\nIO.filesMatching(glob) -&gt; (file) {\n    file.delete()\n    IO.writeLine(\"Deleted {file.name}\")\n}\n</code></pre> <pre><code>use IO from \"https://raw.githubusercontent.com/Jamalam360/jamalang/main/std/io.jamalang\"\n\nfn fib(UnsignedInt n): UnsignedInt {\n    if n == 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    } else {\n        return fib(n - 1) + fib(n - 2)\n    }\n}\n\nn: UnsignedInt = IO.prompt(\"Enter a number: \")\nIO.writeLine(\"Fibonacci of {n} is {fib(n)}\")\n</code></pre> <pre><code># This is how the standard library will implement the `IO.write` and `IO.writeLine` functions.\n# It uses the built-in method `write` and the built-in value `stdout` to write each character in the string to the stdout.\n# `write` will also be usable for things like files.\n\nfn write(String str) {\n    str.chars() -&gt; (char) {\n        write(stdout, char)\n    }\n}\n\nfn writeLine(String str) {\n    write(str)\n    write(0x0A) # 0x0A is the Unicode codepoint for the newline character, implicitly casted to a char\n}\n</code></pre>"},{"location":"specification/requirements/","title":"Jamalang Implementation Requirements","text":"<p>The following document contains information about the requirements (in terms of features) for a specification compliant implementation of a Jamalang transpiler.</p> <p>Jamalang has a number of tests available as well, more information on which can be found in the tests document.</p>"},{"location":"specification/requirements/#basic-syntax","title":"Basic Syntax","text":""},{"location":"specification/requirements/#comments","title":"Comments","text":"<p>Comments are formatted as follows. Jamalang doesn't contain a multi-line comment syntax.</p> <pre><code># This is a comment\nx = 5 # This is also a comment\n</code></pre> <p>Comments can be appended at the end of any line after the statement on that line is completed, or at the start of that line.</p>"},{"location":"specification/requirements/#variables","title":"Variables","text":"<p>Variables are declared in the following format:</p> <pre><code>[NAME]: [TYPE] = [EXPRESSION]\n</code></pre> <p>Where <code>[TYPE]</code> is the type of the variable, which is optional, <code>[NAME]</code> is the name of the variable, and <code>[EXPRESSION]</code> is the value of the variable.</p> <p>For example:</p> <pre><code># UnsignedInt is the default type of a non-negative integer constant.\nx = 5\n</code></pre> <p>Variable names strictly use <code>lower_snake_case</code>. Variable names must not contain upper case characters.</p>"},{"location":"specification/requirements/#constants","title":"Constants","text":"<p>Constants are defined in the same was as variables, but use <code>UPPER_SNAKE_CASE</code>.</p>"},{"location":"specification/requirements/#control-flow","title":"Control Flow","text":"<p>If blocks are defined as such:</p> <pre><code>if expression {\n\n} elif expression2 {\n\n} else {\n\n}\n</code></pre>"},{"location":"specification/requirements/#loops","title":"Loops","text":"<p>Jamalang has both for loops and while loops:</p> <pre><code>for elem in array {\n\n}\n\nwhile condition {\n\n}\n</code></pre>"},{"location":"specification/requirements/#arrays","title":"Arrays","text":"<p>Arrays are defined as such:</p> <pre><code>array = [1, 2, 3, 4, 5]\n\nfor elem in array {\n  # ...\n}\n</code></pre> <p>There is also a range operator. The following code would have the same effect:</p> <pre><code># LB is inclusive, UB is non-inclusive\narray = 1..6\n</code></pre>"},{"location":"specification/requirements/#functions","title":"Functions","text":"<p>Functions are defined in the following form:</p> <pre><code>fn example_function(name: String): String {\n  # Do things with name\n  return name\n}\n</code></pre> <p>If a function doesn't specify a return type, it can be assumed to be Void.</p>"},{"location":"specification/requirements/#lambda-functions","title":"Lambda Functions","text":"<p>If a function specifies a function as its last argument, that function can be used as a lambda function:</p> <pre><code>fn example_lambda(glob: String, consumer: (String, String): Void) {\n  # Find files matching glob...\n  for file in files {\n    consumer(file.name, file.extension)\n  }\n}\n\nexample_lambda(\"*.json\") -&gt; (name, ext) {\n  # Do things with name and ext\n}\n</code></pre>"},{"location":"specification/requirements/#operations","title":"Operations","text":"<p>Jamalang contains the following operators. The name of their constraint is also included.</p> <ul> <li><code>+</code> (Addable)</li> <li><code>-</code> (Subtractable)</li> <li><code>/</code> (Dividable)</li> <li><code>*</code> (Multiplicatable)</li> <li><code>**</code> (Powerable)</li> <li><code>%</code> (Modulusable)</li> <li><code>..</code> (Rangeable)</li> <li><code>&lt;</code> (Comparable)</li> <li><code>&gt;</code> (Comparable)</li> <li><code>&lt;=</code> (Comparable)</li> <li><code>&gt;=</code> (Comparable)</li> <li><code>is</code> (Comparable)</li> <li><code>is not</code> (Comparable)</li> </ul>"},{"location":"specification/requirements/#builtins","title":"Builtins","text":"<p>Jamalang runtime's need to contain a few minimum builtins - the standard library can't do everything.</p>"},{"location":"specification/requirements/#types-primitives","title":"Types (Primitives)","text":""},{"location":"specification/requirements/#unsignedint","title":"<code>UnsignedInt</code>","text":"<p>A 32-bit unsigned integer.</p>"},{"location":"specification/requirements/#signedint","title":"<code>SignedInt</code>","text":"<p>A 32-bit signed integer.</p>"},{"location":"specification/requirements/#long","title":"<code>Long</code>","text":"<p>A 64-bit signed integer.</p>"},{"location":"specification/requirements/#float","title":"<code>Float</code>","text":"<p>A 32-bit floating point number.</p>"},{"location":"specification/requirements/#double","title":"<code>Double</code>","text":"<p>A 64-bit floating point number.</p>"},{"location":"specification/requirements/#boolean","title":"<code>Boolean</code>","text":"<p>A boolean value.</p>"},{"location":"specification/requirements/#char","title":"<code>Char</code>","text":"<p>A Unicode scalar value, similar to Rust's <code>char</code> type.</p>"},{"location":"specification/requirements/#types-other","title":"Types (Other)","text":""},{"location":"specification/requirements/#void","title":"<code>Void</code>","text":"<p>An empty value. This is used as the type of a function that does not return a value. Variables cannot be assigned this type.</p>"},{"location":"specification/requirements/#object","title":"<code>Object</code>","text":"<p>The base type of any object (i.e. any value other than primitives). This is used, for example, to define functions that accept any object as an argument.</p>"},{"location":"specification/requirements/#types-core-library","title":"Types (Core Library)","text":"<p>The core module of the standard library contains a few types that need to be known by the compiler:</p> <ul> <li><code>String</code> (this also needs custom syntax)</li> </ul>"},{"location":"specification/tests/","title":"Jamalang Tests","text":"<p>Jamalang contains a test suite that can be used to verify that a transpiler is compliant with the specification. The test suite is located in the <code>TBD</code> directory. Each test file has an accompanying <code>.out</code> file that contains the expected output of the test.</p> <p>The tests have to be transpiled into JS, then run by a test runner. Their outputs can then be compared with the <code>.out</code> files that accompany them.</p>"}]}